Part I, Goal:

Introduce binomial rings, following J. Elliot's paper.
Binomial rings are torsion-free commutative rings R such that for any x ∈ R and any k ∈ ℕ, we have k! | x(x-1)⋯(x-k+1).
The torsion-free condition implies multiplication by k! is injective, so we define `choose x k` to be the unique y such that y*k! = x(x-1)⋯(x-k+1).

We can generalize this to the following condition on semirings: multiplication by positive integers is injective, and k! | x(x+1)⋯(x+k-1) for all x and k.
This lets us generalize the definition of multichoose to suitable semirings.  Over Nat, multichoose n k = choose (n+k-1) k.

Part II, Theorems about binomial coefficients we need for vertex algebras:

0. Z is a binomial ring.  If ℚ ⊂ R, then k! is invertible, so R is binomial.
1. When x ∈ ℕ, Ring.choose agrees with nat.choose (use nat.desc_factorial_eq_factorial_mul_choose)
2. nat.choose_mul : n.choose k * k.choose s = n.choose s * (n-s).choose (k-s) when k \geq s
   I would prefer to write x.choose (n+k) * (n+k).choose k = x.choose n * (x-n).choose k
   so we know which terms need to be non-negative.
3. (-1)^k x.choose k = (k-x-1).choose k
4. Vandermonde convolution: (x+y).choose k = (finset.range (k+1)).sum (λ (i:ℕ), x.choose i * y.choose (k-i))

Theorems about series we need:
1. Expansions of (x-y)^(-N) when |x| < |y| and |y| < |x|
2. Difference of expansions is annihilated by (x-y)^N
3. Formal taylor expansion of (1+x)^r - need divided-power derivatives
4. If we define (x-y)^r = x^r(1-y/x)^r ∈ x^r R[x^(-1)][[y]]
   when |x|>|y|, show ((x-y)^r)^s = (x-y)^{rs} in the same region.

Part III, Implementation plan:

Introduce ascending factorials `Ring.ascFactorial r k`, for r in a semiring R following data.nat.factorial.basic.
Ring.ascFactorial is a shift by one of Pochhammer.eval that makes some definitions cumbersome.
ascFactorial r k lies in the subsemiring of R generated by r, so in principle, proofs can be done in a commutative semiring.

Define binomial semirings by injective Pnat multiplication and the divisibility criterion.
Show that N is a binomial semiring.
Define Ring.multichoose r k.
Prove multichoose_mul using ascFactorial_mul.  Also, "pascal's triangle" relation.
Prove a multichoose Vandermonde for commuting x and y.

Then, introduce descending factorials Ring.descFactorial r k, for r in a ring R.
Compare with ascFactorial, compare descFactorial r k with descFactorial (k-r-1) k, prove descFactorial_mul.
descFactorial vanderMonde : dF (x+y) n = \sum (choose n k) (dF x k) (dF y (n-k)) := induction on n using Pascal and a sum reindex.

Introduce binomial coefficients Ring.choose r k.  Compare with Nat.choose and Ring.multichoose.
Compare Ring.choose r k with Ring.choose (k-r-1) k, prove Ring.choose_mul.
Here is a silly proof of Ring.vanderMonde: For each k, it suffices to prove a polynomial identity for the universal binomial ring on x and y, and it holds for the Zariski dense set of inputs coming from x and y in Nat.

Part IV, To do:

1. Figure out how to reduce proofs in the noncommutative case to a commutative subsemiring
   (maybe take care of this in a different file? Noncommutative definitions can go in the main file).
   One method: make a left-inverse to the inclusion map, like Int.toNat, that takes elements outside the commutative subring to zero.
   Make theorems like: this map respects products on the subring.  Then, we can reduce equality proofs to the subsemiring.

2. Figure out how to take k! | x(x+1)⋯(x+k-1) (done with existence) and produce an element (done with .choose) and manipulate these (not done yet).

3. Later, consider proving some of Elliott's other results, like how the integer-valued polynomial rings (generated by Ring.choose x n) are universal (commutative) binomial rings. 

